#version 450

#extension GL_EXT_debug_printf : enable
// debugPrintfEXT("hello world %f", 1.0);

#include "rand.comp"

layout(local_size_x = 32, local_size_y = 32) in;
layout(rgba32f, binding = 0) uniform image2D img_output;

// Constants
const int MAT_LAMBERTIAN = 0;
const int MAT_METAL = 1;
const int MAT_DIELECTRIC = 2;

// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385
const float faccuracy = 0.000001;

bool IsNearZero(vec3 v) {
    return (abs(v.x) < faccuracy) && (abs(v.y) < faccuracy) && (abs(v.z) < faccuracy);
}

// TODO: fma
// Source: http://jcgt.org/published/0007/04/01/
// Input inv_view_dir: inverse view direction
// Input alpha: roughness parameter
// Input U: uniform random numbers
// Output Ne: normal sampled with PDF D_Ve(Ne) = G1(Ve) * max(0, dot(Ve, Ne)) * D(Ne) / Ve.z
vec3 SampleGGXVNDF(vec3 inv_view_dir, vec2 alpha, vec2 U) {
    // transforming the view direction to the hemisphere configuration
    vec3 Vh = normalize(vec3(alpha.x * inv_view_dir.x, alpha.y * inv_view_dir.y, inv_view_dir.z));
    
    // orthonormal basis (with special case if cross product is zero)
    float lensq = fma(Vh.x, Vh.x, Vh.y * Vh.y);
    vec3 T1 = lensq > 0 ? vec3(-Vh.y, Vh.x, 0) * inversesqrt(lensq) : vec3(1, 0, 0);
    vec3 T2 = cross(Vh, T1);

    // parameterization of the projected area
    float r = sqrt(U.x);
    float phi = 2.0 * pi * U.y;
    float t1 = r * cos(phi);
    float t2 = r * sin(phi);
    float s = 0.5 * (1.0 + Vh.z);
    t2 = fma((1.0 - s), sqrt(1.0 - t1 * t1), s * t2);
    
    // reprojection onto hemisphere
    vec3 Nh = fma(vec3(t1), T1, fma(vec3(t2), T2, sqrt(max(0.0, 1.0 - t1 * t1 - t2 * t2)) * Vh));
    
    // transforming the normal back to the ellipsoid configuration
    return normalize(vec3(alpha.x * Nh.x, alpha.y * Nh.y, max(0.0, Nh.z)));
}

struct Ray {
    vec3 origin;
    vec3 direction;
};
Ray CreateRay(vec3 origin, vec3 direction);
vec3 RayAt(Ray r, float t);
vec3 RayColor(Ray r);

struct HitRecord {
    vec3 point;
    vec3 normal;
    float t;
    uint index; 
    float internal_reflection;
};

layout(binding = 1) uniform Camera {
    uint image_width;
    uint image_height;

    vec3 horizontal;
    vec3 vertical;
    vec3 lower_left_corner;
    vec3 origin;
    int padding;
    int samples_per_pixel;
    int max_bounce;
} camera;
Ray CameraGetRay(float u, float v);

layout (binding = 2) uniform BrickGridState {
    uint dim_x;
    uint dim_y;
    uint dim_z;
    uint max_ray_iteration;
    // min point *and* base t value
    vec4 min_point_base_t;
    vec4 max_point_scale;
} brick_grid;

// Grid types
const int EMPTY = 0;
const int LOADED = 1; 
const int UNLOADED = 2;
struct GridEntry {
    // 2 first bits are type, 30 next are data according to type
    uint bits;
};
layout (std430, binding = 7) buffer GridBuffer {
    readonly GridEntry grid_entries[];
};

struct Brick {
    // 512 bit voxel set mask
    int solid_mask[16];
    // 24 bit material index + 8 bit lod index
    int indices;
};
layout (std430, binding = 8) buffer BrickBuffer {
    readonly Brick bricks[];
};

layout (std430, binding = 9) buffer MaterialIndicesBuffer {
    // one entry hold 4 indices
    readonly uint material_indices[];
};


// material is represented by 32 bits:
struct Material {
    int type;          // 2 left most bits
    int type_index;   // 15 shifted 2 bits
    int albedo_index; // 15 shifted 17 bits
};
layout (std430, binding = 3) buffer MaterialBuffer {
    readonly int materials[];
};
bool ScatterLambertian(Material material, Ray r_in, inout HitRecord hit, out vec3 attenuation, out Ray scattered);
bool ScatterMetal(Material material, Ray r_in, inout HitRecord hit, out vec3 attenuation, out Ray scattered);
bool ScatterDielectric(Material material, Ray r_in, vec3 hit_c_min, inout HitRecord hit, out vec3 attenuation, out Ray scattered);


struct Albedo {
    vec4 color;
};
layout (std430, binding = 4) buffer AlbedoBuffer {
    readonly Albedo albedos[];
};
vec3 AlbedoColor(uint index);


struct Metal {
    float fuzz;
};
layout (std430, binding = 5) buffer MetalBuffer {
    readonly Metal metal[];
};

struct Dielectric {
    // TODO: fuzz: IR: defined reflection/refraction ratio
    //             fuzz should define reflection/refraction ray spread
    float internal_reflection;
};
layout (std430, binding = 6) buffer DielectricBuffer {
    readonly Dielectric dielectric[];
};

bool BrickHit(Ray r, float t_brick_max, vec3 delta, Brick brick, ivec3 brick_position, out vec3 hit_min, inout HitRecord hit);
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, out HitRecord hit);

// slab hit tests
bool FastInstersect(vec3 p0, vec3 p1, Ray r);
bool AdvIntersect(vec3 p0, vec3 p1, Ray r, float t_min, inout float t_max, inout HitRecord hit);

// TODO: higher level grid optimization
// TODO: re-enable hack in ScatterDielectric
// TODO: test splitting scale and point & base t and point in brick grid
// TODO: normals are trivially calculated in DDA ...
// TODO: plane intersection test is faster than cube
// TODO: bug with refract vs reflect in diel
// TODO: store the current chunk index we stand in for further sampling and bounces!

void main() {
    ivec2 pixel_coord = ivec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);

    vec3 color = vec3(0.0, 0.0, 0.0);
    for (int sample_i = 0; sample_i < camera.samples_per_pixel; sample_i++) {  
        float x = float(pixel_coord.x);
        float y = float(pixel_coord.y);
        // TODO: proper random (blue noise)
        // TODO: remove division
        float noise_x = hash12(vec2(x + sample_i, y) * 0.2 * float(sample_i > 0));
        float u = (x + noise_x) / float(camera.image_width - 1);
        float noise_y = hash12(vec2(x, y + sample_i) * 0.2 * float(sample_i > 0));
        float v = (y + noise_y) / float(camera.image_height - 1);
        Ray ray = CameraGetRay(u, v);
        color += RayColor(ray);
    }

    color = sqrt(color / camera.samples_per_pixel);
    color = clamp(color, 0, 1);
    imageStore(img_output, pixel_coord, vec4(color, 1.0));
}

Ray CreateRay(vec3 origin, vec3 direction) {
    return Ray(origin, normalize(direction));
}

vec3 RayAt(Ray r, float t) {
    // instruction for: t * dir + origin
    return fma(vec3(t), r.direction, r.origin);
}

vec3 RayColor(Ray r) {
    HitRecord hit;
    hit.internal_reflection = 1.0;
    
    Ray current_ray = r;
    vec3 accumulative_attenuation = vec3(1.0);
    int loop_count = 0;
    
    // TODO
    vec3 hit_v_min;
    while (loop_count < camera.max_bounce && GridHit(current_ray, 0.00001, infinity, hit_v_min, hit)){ 
        loop_count += 1;

        Ray scattered;
        vec3 attenuation;
        bool result = false;
        const int material_bits = materials[hit.index];
        const Material material = Material(
            material_bits & 3,  // type
            bitfieldExtract(material_bits, 2, 15), // material index
            bitfieldExtract(material_bits, 17, 15) // albedo color
        );
        switch (material.type) {
        case MAT_LAMBERTIAN: 
            result = ScatterLambertian(material, current_ray, hit, attenuation, scattered);
            break;
        case MAT_METAL: 
            result = ScatterMetal(material, current_ray, hit, attenuation, scattered);
            break;
        case MAT_DIELECTRIC:
            result = ScatterDielectric(material, current_ray, hit_v_min, hit, attenuation, scattered);
            break;
        default: 
            result = false;
            break;
        }
        if (!result) break;
        accumulative_attenuation *= attenuation;
        current_ray = scattered;
    }
    if (loop_count > 0) return accumulative_attenuation;

    float t = 0.5 * (current_ray.direction.y + 1.0);
    vec3 background_color = fma(vec3(1.0 - t), vec3(1.0), t * vec3(0.5, 0.7, 1.0));
    return background_color;
}

bool isInGrid(ivec3 point) {
    return point.x >= 0 && point.x < brick_grid.dim_x 
        && point.y >= 0 && point.y < brick_grid.dim_y
        && point.z >= 0 && point.z < brick_grid.dim_z;
}

bool isInBrick(ivec3 point) {
    return point.x >= 0 && point.x < 8 
        && point.y >= 0 && point.y < 8
        && point.z >= 0 && point.z < 8;
}

void defineStepAndAxis(vec3 dir, vec3 fposition, ivec3 position, vec3 delta, int axis_value, inout ivec3 pos_step, inout vec3 axis_t) {
    const int a = axis_value;
    if (dir[a] < 0) {
        pos_step[a] = -1;
        axis_t[a] = ((fposition[a] - position[a]) * delta[a]) * brick_grid.max_point_scale.w;
    } else {
        pos_step[a] = 1;
        axis_t[a] = ((position[a] + 1 - fposition[a]) * delta[a]) * brick_grid.max_point_scale.w;
    }
}

bool BrickHit(Ray r, float t_min, float t_brick_max, vec3 delta, Brick brick, vec3 brick_position, out vec3 hit_min, inout HitRecord hit) {
    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
    /// get position in brick space from global position
    /// caller should make sure that p is in fact inside the grid
    vec3 fposition = (RayAt(r, hit.t + 0.0001) - brick_position) * 8;
    ivec3 position = ivec3(fposition);

    ivec3 pos_step;
    vec3 axis_t;
    {
        // define x
        defineStepAndAxis(r.direction, fposition, position, delta, 0, pos_step, axis_t);
        // define y
        defineStepAndAxis(r.direction, fposition, position, delta, 1, pos_step, axis_t);
        // define z
        defineStepAndAxis(r.direction, fposition, position, delta, 2, pos_step, axis_t);
    }

    // DDA loop
    while (isInBrick(position)) { 
        const int bit_offset = position.x + 8 * (position.z + 8 * position.y);
        const int mask_index = bit_offset / 32;
        const int mask_offset = bit_offset % 32;
        const int set_bit = bitfieldExtract(brick.solid_mask[mask_index], mask_offset, 1);
        if (set_bit != 0) {
            { // calculate material data
                int bits_before = 0;
                // find and assign material index
                for (int i = 0; i < mask_index; i++) {
                    bits_before += bitCount(brick.solid_mask[i]);
                }
                // bitfieldExtract(brick.solid_mask[mask_index], 0, mask_offset)
                // causes a weird bug where brick.solid_mask[mask_index] = 3, mask_offset = 1
                // results in -1 which in turn results in 32 bit set which is wrong.
                // this is a work around where we simply create a bitmask for solid_mask
                int maskmask = 0;
                for (int i = 0; i < mask_offset; i++) {
                    maskmask |= 1 << i;
                }
                bits_before += bitCount(brick.solid_mask[mask_index] & maskmask);

                const int material_index_index = (bits_before * 8) / 32;
                const int material_index_bit_offset = (bits_before * 8) % 32;

                const uint brick_offset = bitfieldExtract(brick.indices, 0, 24) * 128;
                debugPrintfEXT("brick_offset: %d", brick_offset);
                hit.index = bitfieldExtract(material_indices[material_index_index + brick_offset], material_index_bit_offset, 8);
            }

            // TODO: HACK: calculate T by doing advanced cube hit ...
            const vec3 cube_min = brick_position + (position * 0.125);
            const vec3 cube_max = cube_min + vec3(0.125) + 0.00001;
            AdvIntersect(cube_min, cube_max, r, t_min, t_brick_max, hit);
            
            // TODO: use a determenistic t from DDA
            hit.point = RayAt(r, hit.t - faccuracy);
            const vec3 center = cube_min + vec3(0.0625); // 0.125 / 2
            vec3 normal = hit.point - center;
            const vec3 abs_normal = abs(normal);
            normal.x = normal.x * int(abs_normal.x >= abs_normal.y && abs_normal.x >= abs_normal.z);
            normal.y = normal.y * int(abs_normal.y >= abs_normal.x && abs_normal.y >= abs_normal.z);
            normal.z = normal.z * int(abs_normal.z >= abs_normal.x && abs_normal.z >= abs_normal.y);
            hit.normal = normalize(normal);

            hit_min = cube_min;

            return true;
        }
        
        const int y_smallest = int(axis_t.y < axis_t.x && axis_t.y < axis_t.z);
        const int z_smallest = 2 * int(axis_t.z < axis_t.x && axis_t.z < axis_t.y);
        // set axis, 0 if x smallest, 1 if y is smallest or 2 if z is smallest
        int axis = y_smallest + z_smallest;
        
        position[axis] += pos_step[axis];
        axis_t[axis] += delta[axis];
    }   

    return false;
}

/// Traverses the brick grid and calculates any potential hit with the grid
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, out HitRecord hit) {
    // min point *and* base t value
    const vec3 g_min = brick_grid.min_point_base_t.xyz;
    const vec3 g_max = brick_grid.max_point_scale.xyz;
    const float b_base_t = brick_grid.min_point_base_t.w;
   
    float t_grid_max = t_max;
    HitRecord hit_grid;
    const bool grid_hit = AdvIntersect(g_min, g_max, r, t_min, t_grid_max, hit_grid);
    if (grid_hit == false) {
        return false;
    }

    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
    
    /// get position in grid space from global position
    /// caller should make sure that p is in fact inside the grid
    const vec3 fposition = RayAt(r, hit_grid.t + 0.0001) - g_min;
    ivec3 position = ivec3(fposition);

    // in the event of a axis of direction is 0 we get infinity according to 
    // float specification IEEE 754 (division by 0 is defined as resulting in infinity value)
    vec3 delta = abs(1.0 / r.direction);

    ivec3 pos_step;
    vec3 axis_t;
    {
        // define x
        defineStepAndAxis(r.direction, fposition, position, delta, 0, pos_step, axis_t);
        // define y
        defineStepAndAxis(r.direction, fposition, position, delta, 1, pos_step, axis_t);
        // define z
        defineStepAndAxis(r.direction, fposition, position, delta, 2, pos_step, axis_t);
    }

    // DDA loop
    while (isInGrid(position)) { 
        uint index = position.x + brick_grid.dim_x * (position.z + brick_grid.dim_z * position.y);
        uint bits = grid_entries[index].bits;
        uint entry_type = bitfieldExtract(bits, 0, 2);
        if(bits != 0) { // TODO: actually check type
            // TODO: should be able to extrapolate hit.t from axis_t! (and dont do any cube hit test)
            const vec3 brick_min = g_min + position;
            const vec3 brick_max = brick_min + vec3(brick_grid.max_point_scale.w); 
            float brick_t_max = t_grid_max;
            // progress hit.t
            AdvIntersect(brick_min, brick_max, r, t_min, brick_t_max, hit);
            
            // check if ray hits any voxel in the brick
            const uint brick_index = bitfieldExtract(bits, 2, 30);
            
            if (BrickHit(r, t_min, brick_t_max, delta, bricks[brick_index], brick_min, hit_min, hit)) {
                return true;
            }
            
        }

        const int y_smallest = int(axis_t.y < axis_t.x && axis_t.y < axis_t.z);
        const int z_smallest = 2 * int(axis_t.z < axis_t.x && axis_t.z < axis_t.y);
        // set axis, 0 if x smallest, 1 if y is smallest or 2 if z is smallest
        int axis = y_smallest + z_smallest;
        
        position[axis] += pos_step[axis];
        axis_t[axis] += delta[axis];
    }   

    return false;
}


Ray CameraGetRay(float u, float v) {
    vec3 ray_dir = fma(camera.horizontal, vec3(u), camera.lower_left_corner) + fma(vec3(v), camera.vertical, -camera.origin);
    return CreateRay(camera.origin, ray_dir);
}

vec3 AlbedoColor(Material material) {
    return albedos[material.albedo_index].color.xyz;
}

float maxComponent(vec3 v) {
  return max(max(v.x, v.y), v.z);
}
// Source: http://jcgt.org/published/0007/03/04/ (defined as "slab")
/// Test if a ray intersect with min point p0 and max p1 of a slab
bool FastInstersect(vec3 p0, vec3 p1, Ray r) {
    const vec3 inv_ray_dir = 1 / r.direction;
    const vec3 t0 = (p0 - r.origin) * inv_ray_dir;
    const vec3 t1 = (p1 - r.origin) * inv_ray_dir;
    const vec3 tmin = min(t0, t1), tmax = max(t0, t1);
    return maxComponent(tmin) <= maxComponent(tmax);
}

// TODO: Source: (Ray tracing gems 2) / Peter Shirley
/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
bool AdvIntersect(vec3 p0, vec3 p1, Ray r, float t_min, inout float t_max, inout HitRecord hit) {
    const vec3 inv_ray_dir = 1 / r.direction; 
    const vec3 t_lower = (p0 - r.origin) * inv_ray_dir;
    const vec3 t_upper = (p1 - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    float t_cube_min = t_min;
    float t_cube_max = t_max;
    for (int i = 0; i < 3; i++) {
        t_cube_min = max(t_cube_min, t_mins[i]);
        t_cube_max = min(t_cube_max, t_maxes[i]);
    }
    if (t_cube_min > t_cube_max) {
        return false;
    }

    // store the exit t in t_max
    hit.t = t_cube_min; 
    t_max = t_cube_max;

    return true;
}


// source: https://backend.orbit.dtu.dk/ws/portalfiles/portal/126824972/onb_frisvad_jgt2012_v2.pdf
mat3 constructFrisvad(vec3 normal) {
    mat3 ret;
    ret[1] = normalize(normal); // TODO: normalize here is strictly not required and simply waste computation
    // Handle the singularity
    if(normal.z < -0.9999) {
        ret[0] = vec3(0.0, -1.0, 0.0);
        ret[2] = vec3(-1.0, 0.0, 0.0);
    } else {
        float a = 1.0 / (1.0 + normal.z);
        float b = -normal.x * normal.y * a;
        ret[0] = vec3(1.0 - normal.x * normal.x * a, b, -normal.x);
        ret[2] = vec3(b, 1.0 - normal.y * normal.y * a, -normal.y);
    }

    return ret;
}

bool ScatterLambertian(Material material, Ray r_in, inout HitRecord hit, out vec3 attenuation, out Ray scattered) {
    hit.internal_reflection = 1.0;
    
    vec3 scatter_dir = hit.normal + RandInHemisphere(hit.point.xy + hit.point.z, hit.normal);
    if (IsNearZero(scatter_dir)) scatter_dir = hit.normal;
    scattered = CreateRay(hit.point, scatter_dir);
    attenuation = AlbedoColor(material);
    return true;
}

bool ScatterMetal(Material material, Ray r_in, inout HitRecord hit, out vec3 attenuation, out Ray scattered) {
    hit.internal_reflection = 1.0;

    vec3 reflected = reflect(r_in.direction, normalize(hit.normal));
    float fuzz = metal[material.type_index].fuzz;
    scattered = CreateRay(hit.point, fma(reflected, vec3(fuzz), RandInHemisphere(hit.point.xy + hit.point.z, hit.normal)));
    attenuation = AlbedoColor(material);
    return (dot(scattered.direction, hit.normal) > 0);
}

// Source: Ray tracing gems 2 page 107 (one of Bec's methods)
/// defined the refraction direction if a refraction is needed based on n1, n2 and the angle between
/// r_in and the normal
/// This means that refrac_dir only gets defined if function returns true
/// @param:
///     - n1: internal reflection of impact material
///     - n2: internal reflection of current material medium
///     - ray_dir: the traveling ray direction
///     - normal: normal vector of the impact surface
///     - refrac_dir: poternial calculated penetration vector of r_in
/// @return: bool that is true if refraction is calculated
bool transmissionDirection(float n1, float n2, vec3 ray_dir, vec3 normal, out vec3 refrac_dir) {
    float eta = n1/n2;
    float c1 = -dot(ray_dir, normal);
    float w = eta * c1;
    float c2m = (w - eta) * (w + eta);
    if (c2m < -1.0) {
        return false;
    }
    refrac_dir = fma(vec3(eta), ray_dir, (w - sqrt(1.0 + c2m)) * normal);
    return true;
}

bool ScatterDielectric(Material material, Ray r_in, vec3 hit_c_min, inout HitRecord hit, out vec3 attenuation, out Ray scattered) {
    attenuation = AlbedoColor(material);

    float ir = dielectric[material.type_index].internal_reflection;
    
    // TODO: better noise (blue :))
    // TODO: add property to glass: roughness (0 should be no noise)
    const vec3 normal = normalize(fma(hit.normal, vec3(2), RandInHemisphere(hit.point.xy + hit.point.z, hit.normal)));
    vec3 direction;
    bool do_refract = transmissionDirection(ir, hit.internal_reflection, r_in.direction, normal, direction);
    if (do_refract) {
        scattered = CreateRay(hit.point, direction);
        // TODO: we can remove this if we find the correct t_min for GridHit in calculate raycolor
        // HACK: move scattered ray out of current cube explicitly
        {
            float t_max = 9999.0;
            HitRecord c_hit = hit;
            AdvIntersect(hit_c_min, hit_c_min + vec3(0.125), scattered, 0.0, t_max, c_hit);
            scattered = CreateRay(RayAt(scattered, t_max), scattered.direction);
        }
        hit.internal_reflection = ir;
    } else {
        direction = reflect(r_in.direction, normal);
        scattered = CreateRay(hit.point, direction);
        hit.internal_reflection = 1.0;
    }

    return true;
}

