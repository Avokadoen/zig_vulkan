#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) buffer HitLimitsBuffer {
    HitLimits limits;
};

// incoming rays 
layout (std430, set = 1, binding = 0) readonly buffer InRayBuffer {
    Ray in_rays[];
};
layout (std430, set = 2, binding = 0) readonly buffer InRayShadingBuffer {
    RayShading in_ray_shadings[];
};

// outgoing rays 
layout (std430, set = 3, binding = 0) writeonly buffer OutRayBuffer {
    Ray out_rays[];
};
layout (std430, set = 4, binding = 0) writeonly buffer OutRayHitBuffer {
    RayHit out_ray_hits[];
};
layout (std430, set = 5, binding = 0) writeonly buffer OutRayShadingBuffer {
    RayShading out_ray_shadings[];
};

layout (std430, set = 6, binding = 0) readonly buffer BrickSetBuffer {
    uint brick_set_bits[];
};
layout (std430, set = 6, binding = 1) buffer BrickIndex {
    uint brick_index_req_count_status[];
};
layout (std430, set = 6, binding = 2) readonly buffer BrickBuffer {
    Brick bricks[];
};

// Must be kept in sync with src/modules/voxel_rt/ray_pipeline_types.zig BrickGridState
layout (push_constant) readonly uniform BrickGridState {
    // how many bricks in each axis
    vec3 dim;
    float pading0;
    vec3 min_point;
    float scale;
} brick_grid;

bool AdvIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max);
bool GridHit(inout Ray r, float t_min, float t_max, inout uint normal_index_3b_voxel_index_9b_brick_index_20b);
bool BrickHit(
    inout Ray r, 
    vec3 g_scale, 
    vec3 ray_delta, 
    vec3 ray_delta, 
    float t_min, 
    float t_max, 
    float global_t_value, 
    uint brick_index, 
    vec3 brick_position, 
    inout uint normal_index_3b_voxel_index_9b_brick_index_20b
);

void main() {
    const uint index = gl_GlobalInvocationID.x;
    if (index >= limits.in_hit_count) {
        return;
    }

    Ray ray = in_rays[index];

    // Check if ray has not been tagged as aborted
    vec2 internal_reflection_16b_padding_15b_abort_ray_1b = unpackHalf2x16(ray.internal_reflection_16b_padding_15b_abort_ray_1b);
    const uint abort_ray = floatBitsToUint(internal_reflection_16b_padding_15b_abort_ray_1b.y);
    
    bool ray_hit_grid = false;
    RayShading ray_shading;
    uint normal_index_3b_voxel_index_9b_brick_index_20b = 0;
    if (abort_ray != 1) {
        ray_shading = in_ray_shadings[index];
        // TODO: configurable
        float t_min = 0.001;
        float t_max = 1000 - ray.t_value;
        ray_hit_grid = GridHit(ray, t_min, t_max, normal_index_3b_voxel_index_9b_brick_index_20b);
    }

    if (abort_ray != 1 && ray_hit_grid) {
        const uint out_index = atomicAdd(limits.out_hit_count, 1);
        out_ray_shadings[out_index] = ray_shading;
        out_rays[out_index] = ray;
        out_ray_hits[out_index].normal_index_3b_voxel_index_9b_brick_index_20b = normal_index_3b_voxel_index_9b_brick_index_20b;
    } else {
        const uint out_index = limits.in_hit_count - (atomicAdd(limits.out_miss_count, 1) + 1);
        out_ray_shadings[out_index] = ray_shading;
        out_rays[out_index] = ray;
    }
}


float maxComponent(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}
float minComponent(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}
float safeInverse(float x) { 
    return (x == 0.0) ? 1e12 : (1.0 / x); 
}
vec3 safeInverse(vec3 v) { 
    return vec3(safeInverse(v.x), safeInverse(v.y), safeInverse(v.z)); 
}
float vec3Reduce(vec3 v) { 
    return dot(v, vec3(1)); 
}


/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
/// 
/// Source: Ray tracing gems 2 & Peter Shirley
bool AdvIntersect(vec3 min_point, vec3 max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max) {
    const vec3 t_lower = (min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    t_min = max(t_min, maxComponent(t_mins));
    t_max = min(t_max, minComponent(t_maxes));
    return t_min <= t_max;
}

/// Test if a ray intersect with min point p0 and max p1 of a slab and calculate intersection normal
bool AdvNormIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, out uint normal_bits, inout float t_min, inout float t_max) {
    const vec3 t_lower = (box_min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (box_max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    
    if (t_mins.x >= t_mins.y && t_mins.x >= t_mins.z) {
        t_min = max(t_min, t_mins.x);
        normal_bits = ((inv_ray_dir.x < 0) ? 3 : 0) << NORMAL_BITS_OFFSET;
    } else if (t_mins.y >= t_mins.x && t_mins.y >= t_mins.z) {
        t_min = max(t_min, t_mins.y);
        normal_bits = ((inv_ray_dir.y < 0) ? 4 : 1) << NORMAL_BITS_OFFSET;
    } else {
        t_min = max(t_min, t_mins.z);
        normal_bits = ((inv_ray_dir.z < 0) ? 5 : 2) << NORMAL_BITS_OFFSET;
    }
    t_max = min(t_max, minComponent(t_maxes));
    
    return t_min <= t_max;
}

/// Traverses the brick grid and calculates any potential hit with the grid
bool GridHit(inout Ray r, float t_min, float t_max, inout uint normal_index_3b_voxel_index_9b_brick_index_20b) {
    const vec3 g_scale = vec3(brick_grid.scale);
    const vec3 g_dim = brick_grid.dim;

    const vec3 g_min = brick_grid.min_point;
    const vec3 g_max = fma(g_dim, vec3(g_scale), g_min);

    const vec3 inv_ray_dir = safeInverse(r.direction);
    float grid_t_min = t_min;
    float grid_t_max = t_max;
    if (!AdvNormIntersect(g_min, g_max, r, inv_ray_dir, normal_index_3b_voxel_index_9b_brick_index_20b, grid_t_min, grid_t_max)) {
        return false;
    }

    // HACK: workaround for precision issues with t being too low for "penetrating" grid 
    float global_t_value = grid_t_min + 0.001 * g_scale.x;

    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
   	const vec3 ray_delta = abs(inv_ray_dir);
	const vec3 ray_step = sign(r.direction);
    
    vec3 hit_point = RayAt(r, global_t_value);

    // get position in grid space from global position
    const vec3 fposition = (hit_point - g_min) / g_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    // TODO: make this line more readable, only calculate once 
    const uvec3 normal_axis_bits = uvec3(
        ((ray_step.x < 0) ? AXIS_X_RIGHT_INDEX : AXIS_X_LEFT_INDEX) << NORMAL_BITS_OFFSET,
        ((ray_step.y < 0) ? AXIS_Y_UP_INDEX : AXIS_Y_DOWN_INDEX) << NORMAL_BITS_OFFSET,
        ((ray_step.z < 0) ? AXIS_Z_FRONT_INDEX : AXIS_Z_FRONT_INDEX) << NORMAL_BITS_OFFSET
    );

    float t_value = 0;
    vec3 local_position = floor(fposition + 0.);
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, g_dim)) 
        && global_t_value <= t_max
    ) { 
        const uint grid_index = uint(floor(local_position.x + g_dim.x * (local_position.z + g_dim.z * local_position.y)));
        
        // If brick has some voxels
        if (bitfieldExtract(brick_set_bits[grid_index / 32], int(mod(grid_index, 32)), 1) != 0) {
            const uint brick_index_bits = brick_index_req_count_status[grid_index];
            const uint brick_status = bitfieldExtract(brick_index_bits, BRICK_STATUS_OFFSET, BRICK_STATUS_BITS);

            // increment the req_count if it is not "in flight", ignore RC and just increment it atleast once
            const uint req_count = bitfieldExtract(brick_index_bits, BRICK_REQUEST_COUNT_OFFSET, BRICK_REQUEST_COUNT_BITS);
            if (req_count < BRICK_REQUEST_COUNT_MAX_VALUE && (brick_status == BRICK_STATUS_LOADED || brick_status == BRICK_STATUS_UNLOADED)) {
                brick_index_req_count_status[grid_index] = bitfieldInsert(brick_index_bits, req_count + 1, BRICK_REQUEST_COUNT_OFFSET, BRICK_REQUEST_COUNT_BITS);
            }

            if (brick_status == BRICK_STATUS_LOADED) {
                const uint brick_index = bitfieldExtract(brick_index_bits, BRICK_INDEX_OFFSET, BRICK_INDEX_BITS);
                // convert local position to the world space coordinate for the brick
                vec3 brick_min = fma(local_position, g_scale, brick_grid.min_point);
                global_t_value = t_value + grid_t_min + 0.01 * g_scale.x;
                // check if ray hits any voxel in the brick
                if (BrickHit(
                    r,
                    ray_step,
                    ray_delta,
                    g_scale,
                    grid_t_min,
                    t_max,
                    global_t_value,
                    brick_index,
                    brick_min,
                    normal_index_3b_voxel_index_9b_brick_index_20b
                )) {
                    return true;
                }
            } 
            else {
                // wait for brick to be loaded before we trace this grid section
                return false;
            }
        }
        
        // progress position with DDA
        if (side_dist.x < side_dist.y) {
            if (side_dist.x < side_dist.z) {
                t_value = side_dist.x * g_scale.x;
                side_dist.x += ray_delta.x;
                local_position.x += ray_step.x;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.x;
            }
            else {
                t_value = side_dist.z * g_scale.x;
                side_dist.z += ray_delta.z;
                local_position.z += ray_step.z;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.z;
            }
        }
        else {
            if (side_dist.y < side_dist.z) {
                t_value = side_dist.y * g_scale.x;
                side_dist.y += ray_delta.y;
                local_position.y += ray_step.y;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.y;
            }
            else {
                t_value = side_dist.z * g_scale.x;
                side_dist.z += ray_delta.z;
                local_position.z += ray_step.z;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.z;
            }
        }
    }
    
    return false;
}

bool BrickHit(
    inout Ray r, 
    vec3 ray_step, 
    vec3 ray_delta, 
    vec3 g_scale, 
    float t_min, 
    float t_max, 
    float global_t_value, 
    uint brick_index, 
    vec3 brick_position, 
    inout uint normal_index_3b_voxel_index_9b_brick_index_20b
) {
    vec3 voxel_scale = g_scale * vec3(0.125);
    // optimization: copy solid mask from SSBO to localize the mask memory
    const uint solid_mask[16] = bricks[brick_index].solid_mask;

    /// get position in brick space from global position
    const vec3 fposition = (RayAt(r, global_t_value) - brick_position) / voxel_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    
    // TODO: make this line more readable, only calculate once 
    const uvec3 normal_axis_bits = uvec3(
        ((ray_step.x < 0) ? AXIS_X_RIGHT_INDEX : AXIS_X_LEFT_INDEX) << NORMAL_BITS_OFFSET,
        ((ray_step.y < 0) ? AXIS_Y_UP_INDEX : AXIS_Y_DOWN_INDEX) << NORMAL_BITS_OFFSET,
        ((ray_step.z < 0) ? AXIS_Z_FRONT_INDEX : AXIS_Z_FRONT_INDEX) << NORMAL_BITS_OFFSET
    );

    vec3 local_position = floor(fposition + 0.);
    float local_t_min = t_min - global_t_value;
    float local_t_max = t_max - global_t_value;
    float t_value = 0;
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, vec3(8))) 
        && t_value <= local_t_max
    ) { 
        const int voxel_index = int(floor(local_position.x + 8 * (local_position.z + 8 * local_position.y)));
        const int mask_index = voxel_index / 32;
        const int mask_offset = voxel_index % 32;
        const uint uint_mask = solid_mask[mask_index];
        const uint bitfield_final_entry = bitfieldExtract(uint_mask, mask_offset, 1);

        const bool hit_voxel = (bitfield_final_entry != 0) && t_value >= local_t_min;
        if (hit_voxel) {
            // update ray with new t value for writeback
            r.t_value += global_t_value + t_value;

            // register brick and voxel index and the normal for the hit
            normal_index_3b_voxel_index_9b_brick_index_20b  = bitfieldInsert(
                normal_index_3b_voxel_index_9b_brick_index_20b,
                voxel_index,
                20,
                9
            );
            normal_index_3b_voxel_index_9b_brick_index_20b  = bitfieldInsert(
                normal_index_3b_voxel_index_9b_brick_index_20b,
                brick_index,
                0,
                20
            );
            return true;
        }

        // progress position with DDA
        if (side_dist.x < side_dist.y) {
            if (side_dist.x < side_dist.z) {
                t_value = side_dist.x * voxel_scale.x;
                side_dist.x += ray_delta.x;
                local_position.x += ray_step.x;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.x;
            }
            else {
                t_value = side_dist.z * voxel_scale.x;
                side_dist.z += ray_delta.z;
                local_position.z += ray_step.z;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.z;
            }
        }
        else {
            if (side_dist.y < side_dist.z) {
                t_value = side_dist.y * voxel_scale.x;
                side_dist.y += ray_delta.y;
                local_position.y += ray_step.y;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.y;
            }
            else {
                t_value = side_dist.z * voxel_scale.x;
                side_dist.z += ray_delta.z;
                local_position.z += ray_step.z;
                normal_index_3b_voxel_index_9b_brick_index_20b = normal_axis_bits.z;
            }
        }
    } 

    return false;
}
