#version 450

#extension GL_EXT_debug_printf : enable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385
const float faccuracy = 0.000001;

layout (set = 0, binding = 0) buffer InRayBufferCursor
{
    int in_ray_cursor;
};
layout (set = 0, binding = 1) readonly buffer InRayBuffer {
    Ray in_rays[];
};

layout (set = 0, binding = 2) buffer OutRayBufferCursor
{
    int out_ray_cursor;
};
layout (set = 0, binding = 3) writeonly buffer OutRayBuffer {
    Ray out_rays[];
};

layout (set = 0, binding = 4) readonly buffer BrickGridState {
    // how many voxels in each axis
    vec3 voxel_dim;
    float padding0;

    // how many bricks in each axis
    vec3 dim;
    float padding1;

    vec3 min_point;
    float scale;
} brick_grid;

struct Brick {
    // 512 bit voxel set mask
    uint solid_mask[16];
};
layout (set = 0, binding = 5) readonly buffer BrickBuffer {
    Brick bricks[];
};


bool AdvIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max);
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, inout HitRecord hit);
bool BrickHit(Ray r, float t_min, float t_max, vec3 delta, int brick_index, inout vec3 brick_position, inout HitRecord hit);

shared int in_warp_start_index;
shared uint out_warp_start_index;

void main() {
    if (gl_LocalInvocationIndex == 0) {
        const uint work_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
        in_warp_start_index = int(work_size) * atomicAdd(in_ray_cursor, -1);
        out_warp_start_index = work_size * atomicAdd(out_ray_cursor, 1);
    }
    barrier();
    if (in_warp_start_index < 0) return;

    const int in_ray_index = in_warp_start_index + int(gl_LocalInvocationIndex);
    Ray ray = in_rays[in_ray_index];

    float t_min = 0.0001;
    float t_max = 1000;
    vec3 hit_v_min;
    HitRecord hit;
    if (GridHit(ray, t_min, t_max, hit_v_min, hit)) {
        ray.t_value = hit.t;
        ray.color = vec3(1);
    }

    const uint out_ray_index = out_warp_start_index + gl_LocalInvocationIndex;
    out_rays[out_ray_index] = ray;
}


float maxComponent(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}
float minComponent(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}
float safeInverse(float x) { return (x == 0.0) ? 1e12 : (1.0 / x); }
vec3 safeInverse(vec3 v) { return vec3(safeInverse(v.x), safeInverse(v.y), safeInverse(v.z)); }
float vec3Reduce(vec3 v) { return dot(v, vec3(1)); }


/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
/// 
/// Source: Ray tracing gems 2 & Peter Shirley
bool AdvIntersect(vec3 min_point, vec3 max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max) {
    const vec3 t_lower = (min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    t_min = max(t_min, maxComponent(t_mins));
    t_max = min(t_max, minComponent(t_maxes));
    return t_min <= t_max;
}

/// Test if a ray intersect with min point p0 and max p1 of a slab and calculate intersection normal
bool AdvNormIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, out vec3 normal, inout float t_min, inout float t_max) {
    const vec3 t_lower = (box_min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (box_max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    
    if (t_mins.x >= t_mins.y && t_mins.x >= t_mins.z) {
        t_min = max(t_min, t_mins.x);
        normal = vec3(sign(r.direction.x) * -1, 0, 0);
    } else if (t_mins.y >= t_mins.x && t_mins.y >= t_mins.z) {
        t_min = max(t_min, t_mins.y);
        normal = vec3(0, sign(r.direction.y) * -1, 0);
    } else {
        t_min = max(t_min, t_mins.z);
        normal = vec3(0, 0, sign(r.direction.z) * -1);
    }
    t_max = min(t_max, minComponent(t_maxes));
    
    return t_min <= t_max;
}

/// Traverses the brick grid and calculates any potential hit with the grid
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, inout HitRecord hit) {
    const vec3 g_min = brick_grid.min_point;
    const vec3 g_max = fma(vec3(brick_grid.scale), brick_grid.dim, brick_grid.min_point);
    const float g_scale = brick_grid.scale;
    const vec3 g_dim = brick_grid.dim;

    const vec3 inv_ray_dir = safeInverse(r.direction);

    float t_grid_min = t_min;
    float t_grid_max = t_max;
    if (!AdvNormIntersect(g_min, g_max, r, inv_ray_dir, hit.normal, t_grid_min, t_grid_max)) {
        return false;
    }
    // HACK: workaround for precision issues with t being too low for "penetrating" grid 
    t_grid_min += 0.001;

    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
    
    /// get position in grid space from global position
    const vec3 fposition = RayAt(r, t_grid_min) - g_min; 
    vec3 position = vec3(floor(fposition));

   	vec3 delta_dist = abs(inv_ray_dir);
	vec3 ray_step = sign(r.direction);
	vec3 side_dist = (ray_step * (position - r.origin) + (ray_step * 0.5) + 0.5) * delta_dist; 

    float t_value = 0;
    const float scale_t_max = t_max * g_scale;
    while (
        minComponent(position) >= 0 && 
        position.x < g_dim.x && position.y < g_dim.y && position.z < g_dim.z &&
        t_value <= scale_t_max
    ) { 
        const int grid_index = int(floor(position.x + g_dim.x * (position.z + g_dim.z * position.y)));

        vec3 brick_min = g_min + position;

        hit.t = fma(t_value, g_scale, t_grid_min);
        // check if ray hits any voxel in the brick
        if (BrickHit(r, t_min, t_grid_max, delta_dist, grid_index, brick_min, hit)) {
            hit_min = brick_min;
            return true;
        }

        // progress position with DDA
        if (side_dist.x < side_dist.y) {
            if (side_dist.x < side_dist.z) {
                t_value = side_dist.x;

                side_dist.x += delta_dist.x;
                position.x += ray_step.x;
            }
            else {
                t_value = side_dist.z;

                side_dist.z += delta_dist.z;
                position.z += ray_step.z;
            }
        }
        else {
            if (side_dist.y < side_dist.z) {
                t_value = side_dist.y;

                side_dist.y += delta_dist.y;
                position.y += ray_step.y;
            }
            else {
                t_value = side_dist.z;

                side_dist.z += delta_dist.z;
                position.z += ray_step.z;
            }
        }
    }   

    return false;
}

bool BrickHit(Ray r, float t_min, float t_max, vec3 delta_dist, int brick_index, inout vec3 brick_position, inout HitRecord hit) {
    
    float voxel_scale = brick_grid.scale * 0.125;
    
    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
    /// get position in brick space from global position
    /// caller should make sure that p is in fact inside the grid
    const vec3 fposition = (RayAt(r, hit.t + 0.0001) - brick_position) * 8;
    vec3 position = vec3(floor(fposition));

    // optimization: copy solid mask from SSBO to localize the mask memory
    const uint solid_mask[16] = bricks[brick_index].solid_mask;

	vec3 ray_step = sign(r.direction);
	vec3 side_dist = (ray_step * (position - r.origin) + (ray_step * 0.5) + 0.5) * delta_dist; 

    // DDA loop
    float t_value = 0; // TODO: while must respect the hit.t value so far
    const float scaled_t_max = voxel_scale * t_max;
    while (minComponent(position) >= 0 && maxComponent(position) < 8 && t_value <= scaled_t_max) { 
        const int bit_offset = int(floor(position.x + 8 * (position.z + 8 * position.y)));
        const int mask_index = bit_offset / 32;
        const int mask_offset = bit_offset % 32;
        const uint uint_mask = solid_mask[mask_index];
        const uint bitfield_final_entry = bitfieldExtract(uint_mask, 0, mask_offset + 1);

        // TODO: if t_value >= t_min
        if ((bitfield_final_entry & (1 << mask_offset)) != 0) {
            hit.t = fma(t_value, voxel_scale, hit.t);
            hit.point = RayAt(r, hit.t);
            brick_position = fma(position, vec3(voxel_scale), brick_position);
            return true;
        }

        // progress position with DDA
        if (side_dist.x < side_dist.y) {
            if (side_dist.x < side_dist.z) {
                t_value = side_dist.x;

                side_dist.x += delta_dist.x;
                position.x += ray_step.x;
                hit.normal = vec3(-ray_step.x, 0, 0);
            }
            else {
                t_value = side_dist.z;

                side_dist.z += delta_dist.z;
                position.z += ray_step.z;
                hit.normal = vec3(0, 0, -ray_step.z);
            }
        }
        else {
            if (side_dist.y < side_dist.z) {
                t_value = side_dist.y;

                side_dist.y += delta_dist.y;
                position.y += ray_step.y;
                hit.normal = vec3(0, -ray_step.y, 0);
            }
            else {
                t_value = side_dist.z;
                side_dist.z += delta_dist.
                z;
                position.z += ray_step.z;
                hit.normal = vec3(0, 0, -ray_step.z);
            }
        }
    }   

    return false;
}
