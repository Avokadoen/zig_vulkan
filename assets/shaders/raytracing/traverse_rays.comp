#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385
const float faccuracy = 0.000001;

layout (std430, set = 0, binding = 0) buffer HitLimitsBuffer {
    HitLimits limits;
};
layout (std430, set = 1, binding = 0) buffer RayBuffer {
    Ray rays[];
};
layout (std430, set = 2, binding = 0) buffer RayHitBuffer {
    RayHit ray_hits[];
};
layout (std430, set = 3, binding = 0) buffer RayActiveBuffer {
    RayActive ray_actives[];
};
// TODO: BEFORE COMMIT remove
layout (std430, set = 4, binding = 0) buffer RayShadingBuffer {
    RayShading ray_shadings[];
};

layout (std430, set = 5, binding = 0) readonly buffer BrickSetBuffer {
    uint brick_set_bits[];
};
struct Brick {
    // 512 bit voxel set mask
    uint solid_mask[16];
};
layout (std430, set = 5, binding = 1) readonly buffer BrickBuffer {
    Brick bricks[];
};

layout (push_constant) readonly uniform BrickGridState {
    // how many bricks in each axis
    vec3 dim;
    float pading0;
    vec3 min_point;
    float scale;
} brick_grid;

bool AdvIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max);
bool GridHit(Ray r, float t_min, float t_max, uint buffer_index);
bool BrickHit(Ray r, vec3 g_scale, vec3 ray_delta, vec3 ray_delta, float t_min, float t_max, float global_t_value, int brick_index, vec3 brick_position, uint hit_normal_bits, uint buffer_index);

void main() {
    const uint index = gl_GlobalInvocationID.x;
    if (index >= limits.in_hit_count) {
        return;
    }

    Ray ray = rays[index];

    // TODO: configurable
    float t_min = 0.0001;
    float t_max = 1000 - ray.t_value;
    if (GridHit(ray, t_min, t_max, index)) {
        ray_shadings[index].color = vec3(1);
        ray_actives[index].is_active = true;
        atomicAdd(limits.out_hit_count, 1);
    } else {
        ray_actives[index].is_active = false;
        atomicAdd(limits.out_miss_count, 1);
    }
}


float maxComponent(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}
float minComponent(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}
float safeInverse(float x) { 
    return (x == 0.0) ? 1e12 : (1.0 / x); 
}
vec3 safeInverse(vec3 v) { 
    return vec3(safeInverse(v.x), safeInverse(v.y), safeInverse(v.z)); 
}
float vec3Reduce(vec3 v) { 
    return dot(v, vec3(1)); 
}


/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
/// 
/// Source: Ray tracing gems 2 & Peter Shirley
bool AdvIntersect(vec3 min_point, vec3 max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max) {
    const vec3 t_lower = (min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    t_min = max(t_min, maxComponent(t_mins));
    t_max = min(t_max, minComponent(t_maxes));
    return t_min <= t_max;
}

/// Test if a ray intersect with min point p0 and max p1 of a slab and calculate intersection normal
bool AdvNormIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, out uint normal_bits, inout float t_min, inout float t_max) {
    const vec3 t_lower = (box_min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (box_max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    
    if (t_mins.x >= t_mins.y && t_mins.x >= t_mins.z) {
        t_min = max(t_min, t_mins.x);
        normal_bits = ((inv_ray_dir.x < 0) ? 3 : 0) << 28;
    } else if (t_mins.y >= t_mins.x && t_mins.y >= t_mins.z) {
        t_min = max(t_min, t_mins.y);
        normal_bits = ((inv_ray_dir.y < 0) ? 4 : 1) << 28;
    } else {
        t_min = max(t_min, t_mins.z);
        normal_bits = ((inv_ray_dir.z < 0) ? 5 : 2) << 28;
    }
    t_max = min(t_max, minComponent(t_maxes));
    
    return t_min <= t_max;
}

/// Traverses the brick grid and calculates any potential hit with the grid
bool GridHit(Ray r, float t_min, float t_max, uint buffer_index) {
    const vec3 g_scale = vec3(brick_grid.scale);
    const vec3 g_dim = brick_grid.dim;

    const vec3 g_min = brick_grid.min_point;
    const vec3 g_max = fma(g_dim, vec3(g_scale), g_min);

    uint hit_normal_bits;
    const vec3 inv_ray_dir = safeInverse(r.direction);
    float grid_t_min = t_min;
    float grid_t_max = t_max;
    if (!AdvNormIntersect(g_min, g_max, r, inv_ray_dir, hit_normal_bits, grid_t_min, grid_t_max)) {
        return false;
    }

    // HACK: workaround for precision issues with t being too low for "penetrating" grid 
    float global_t_value = grid_t_min + 0.001 * g_scale.x;

    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
   	const vec3 ray_delta = abs(inv_ray_dir);
	const vec3 ray_step = sign(inv_ray_dir);
    
    vec3 hit_point = RayAt(r, global_t_value);

    // get position in grid space from global position
    const vec3 fposition = (hit_point - g_min) / g_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    float t_value = 0;
    vec3 local_position = floor(fposition + 0.);
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, g_dim)) 
        && global_t_value <= t_max
    ) { 
        const int grid_index = int(floor(local_position.x + g_dim.x * (local_position.z + g_dim.z * local_position.y)));
        
        // extract the bit for this brick and check if it is set 
        if (brick_set_bits[grid_index/32]%32 != 0) {
            // Convert local position to the world space coordinate for the brick
            vec3 brick_min = fma(local_position, g_scale, brick_grid.min_point);
            global_t_value = t_value + grid_t_min + 0.01 * g_scale.x;
            // check if ray hits any voxel in the brick
            if (BrickHit(r, ray_step, ray_delta, g_scale, grid_t_min, t_max, global_t_value, grid_index, brick_min, hit_normal_bits, buffer_index)) {
                return true;
            }
        }

        // TODO: With ray coherency, we should probably just always use DDA branches since they will be mostly coherent and the sorting
        // instruction cost might catch up without it

        // progress position with DDA
        const vec3 mask = vec3(lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy)));
        t_value = vec3Reduce(mask * side_dist) * g_scale.x;
        side_dist += mask * ray_delta;
        local_position += mask * ray_step;
    }
    
    return false;
}

bool BrickHit(Ray r, vec3 ray_step, vec3 ray_delta, vec3 g_scale, float t_min, float t_max, float global_t_value, int brick_index, vec3 brick_position, uint hit_normal_bits, uint buffer_index) {
    vec3 voxel_scale = g_scale * vec3(0.125);
    // optimization: copy solid mask from SSBO to localize the mask memory
    const uint solid_mask[16] = bricks[brick_index].solid_mask;

    /// get position in brick space from global position
    const vec3 fposition = (RayAt(r, global_t_value) - brick_position) / voxel_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    // TODO: make this line more readable, only calculate once 
    const uvec3 normal_axis_bits = uvec3(
        ((ray_step.x < 0) ? 3 : 0) << 28,
        ((ray_step.y < 0) ? 4 : 1) << 28,
        ((ray_step.z < 0) ? 5 : 2) << 28
    );

    vec3 local_position = floor(fposition + 0.);
    float local_t_min = t_min - global_t_value;
    float local_t_max = t_max - global_t_value;
    float t_value = 0;
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, vec3(8))) 
        && t_value <= local_t_max
    ) { 
        const int bit_offset = int(floor(local_position.x + 8 * (local_position.z + 8 * local_position.y)));
        const int mask_index = bit_offset / 32;
        const int mask_offset = bit_offset % 32;
        const uint uint_mask = solid_mask[mask_index];
        const uint bitfield_final_entry = bitfieldExtract(uint_mask, 0, mask_offset + 1);

        const bool hit_voxel = ((bitfield_final_entry & (1 << mask_offset)) != 0) && t_value >= local_t_min;
        if (hit_voxel) {
            const uint material_index = 0; // TODO
            const float intersect_t = global_t_value - 0.01 * voxel_scale.x;

            // write back ray with new values
            r.origin = RayAt(r, intersect_t);
            r.t_value += intersect_t;
            rays[buffer_index] = r;

            // register material index and the normal for the hit
            ray_hits[buffer_index].normal_4b_and_material_index_28b = hit_normal_bits | material_index;
            return true;
        }

        // TODO: With ray coherency, we should probably just always use DDA branches since they will be mostly coherent and the sorting
        // instruction cost might catch up without it

        // progress position with DDA
        const bvec3 mask = lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy));
        const vec3 fmask = vec3(mask);
        t_value = vec3Reduce(fmask * side_dist) * voxel_scale.x;
        side_dist += fmask * ray_delta;
        local_position += fmask * ray_step;
        
        // overwrite all bits with normal bits, material index is not defined yet.
        hit_normal_bits = normal_axis_bits.x * uint(mask.x) + normal_axis_bits.y * uint(mask.y) + normal_axis_bits.z * uint(mask.z);
    } 

    return false;
}
