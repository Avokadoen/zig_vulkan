#version 450

#extension GL_EXT_debug_printf : enable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385
const float faccuracy = 0.000001;

layout (set = 0, binding = 0) buffer InCursorBuffer
{
    RayBufferCursor in_ray_cursor;
};
layout (set = 0, binding = 1) readonly buffer InRayBuffer {
    Ray in_rays[];
};

layout (set = 0, binding = 2) buffer OutBufferCursor
{
    RayBufferCursor out_ray_cursor;
};
layout (set = 0, binding = 3) writeonly buffer OutRayBuffer {
    Ray out_rays[];
};

layout (set = 0, binding = 4) readonly buffer BrickGridState {
    // how many voxels in each axis
    vec3 voxel_dim;
    float padding0;

    // how many bricks in each axis
    vec3 dim;
    float padding1;

    vec3 min_point;
    float scale;
} brick_grid;

struct Brick {
    // 512 bit voxel set mask
    uint solid_mask[16];
};
layout (set = 0, binding = 5) readonly buffer BrickBuffer {
    Brick bricks[];
};


bool AdvIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max);
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, inout HitRecord hit);
bool BrickHit(Ray r, vec3 g_scale, vec3 ray_delta, float t_min, float t_max, int brick_index, inout vec3 brick_position, inout HitRecord hit);

shared int in_warp_start_index;
shared uint out_warp_start_index;

void main() {
    const uint work_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
    if (gl_LocalInvocationIndex == 0) {
        in_warp_start_index = int(work_size) * atomicAdd(in_ray_cursor.cursor, -1);
    }
    barrier();

    const int in_ray_index = in_warp_start_index + int(gl_LocalInvocationIndex);
    if (in_ray_index < 0 || in_ray_index > in_ray_cursor.max_index) return;
    Ray ray = in_rays[in_ray_index];

    float t_min = 0.0001;
    float t_max = 1000;
    vec3 hit_v_min;
    HitRecord hit;
    if (GridHit(ray, t_min, t_max, hit_v_min, hit)) {
        ray.color = vec3(1);
        ray.t_value = hit.t;
    }

    if (gl_LocalInvocationIndex == 0) {
        out_warp_start_index = work_size * atomicAdd(out_ray_cursor.cursor, 1);
    }
    barrier();

    const uint out_ray_index = out_warp_start_index + gl_LocalInvocationIndex;
    out_rays[out_ray_index] = ray;
    atomicMax(out_ray_cursor.max_index, int(out_ray_index));
}


float maxComponent(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}
float minComponent(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}
float safeInverse(float x) { 
    return (x == 0.0) ? 1e12 : (1.0 / x); 
}
vec3 safeInverse(vec3 v) { 
    return vec3(safeInverse(v.x), safeInverse(v.y), safeInverse(v.z)); 
}
float vec3Reduce(vec3 v) { 
    return dot(v, vec3(1)); 
}


/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
/// 
/// Source: Ray tracing gems 2 & Peter Shirley
bool AdvIntersect(vec3 min_point, vec3 max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max) {
    const vec3 t_lower = (min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    t_min = max(t_min, maxComponent(t_mins));
    t_max = min(t_max, minComponent(t_maxes));
    return t_min <= t_max;
}

/// Test if a ray intersect with min point p0 and max p1 of a slab and calculate intersection normal
bool AdvNormIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, out vec3 normal, inout float t_min, inout float t_max) {
    const vec3 t_lower = (box_min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (box_max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    
    if (t_mins.x >= t_mins.y && t_mins.x >= t_mins.z) {
        t_min = max(t_min, t_mins.x);
        normal = vec3(sign(r.direction.x) * -1, 0, 0);
    } else if (t_mins.y >= t_mins.x && t_mins.y >= t_mins.z) {
        t_min = max(t_min, t_mins.y);
        normal = vec3(0, sign(r.direction.y) * -1, 0);
    } else {
        t_min = max(t_min, t_mins.z);
        normal = vec3(0, 0, sign(r.direction.z) * -1);
    }
    t_max = min(t_max, minComponent(t_maxes));
    
    return t_min <= t_max;
}

/// Traverses the brick grid and calculates any potential hit with the grid
bool GridHit(Ray r, float t_min, float t_max, out vec3 hit_min, inout HitRecord hit) {
    const vec3 g_scale = vec3(brick_grid.scale);
    const vec3 g_dim = brick_grid.dim;

    const vec3 g_min = brick_grid.min_point;
    const vec3 g_max = fma(g_dim, vec3(g_scale), g_min);

    const vec3 inv_ray_dir = safeInverse(r.direction);
    float grid_t_min = t_min;
    float grid_t_max = t_max;
    if (!AdvNormIntersect(g_min, g_max, r, inv_ray_dir, hit.normal, grid_t_min, grid_t_max)) {
        return false;
    }
    // HACK: workaround for precision issues with t being too low for "penetrating" grid 
    hit.t = grid_t_min + 0.001 * g_scale.x;

    // Perform 3DDDA, source: https://lodev.org/cgtutor/raycasting.html
   	const vec3 ray_delta = abs(inv_ray_dir);
	const vec3 ray_step = sign(inv_ray_dir);
    
    // get position in grid space from global position
    const vec3 fposition = (RayAt(r, hit.t) - g_min) / g_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    float t_value = 0;
    vec3 local_position = floor(fposition + 0.);
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, g_dim)) 
        && hit.t <= t_max
    ) { 
        const int grid_index = int(floor(local_position.x + g_dim.x * (local_position.z + g_dim.z * local_position.y)));
        
        // Convert local position to the world space coordinate for the brick
        vec3 brick_min = fma(local_position, g_scale, brick_grid.min_point);
        hit.t = t_value + grid_t_min + 0.01 * g_scale.x;
        // check if ray hits any voxel in the brick
        if (BrickHit(r, ray_step, g_scale, grid_t_min, t_max, grid_index, brick_min, hit)) {
            hit_min = brick_min;
            return true;
        }

        // progress position with DDA
        const vec3 mask = vec3(lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy)));
        t_value = vec3Reduce(mask * side_dist) * g_scale.x;
        side_dist += mask * ray_delta;
        local_position += mask * ray_step;
    }
    
    return false;
}

bool BrickHit(Ray r, vec3 ray_step, vec3 g_scale, float t_min, float t_max, int brick_index, inout vec3 brick_position, inout HitRecord hit) {
    vec3 voxel_scale = g_scale * vec3(0.125);
    // optimization: copy solid mask from SSBO to localize the mask memory
    const uint solid_mask[16] = bricks[brick_index].solid_mask;

    const vec3 ray_delta = abs(safeInverse(r.direction));
    /// get position in brick space from global position
    const vec3 fposition = (RayAt(r, hit.t) - brick_position) / voxel_scale;
    const vec3 intersection_delta = floor(fposition) - fposition;
    vec3 side_dist = fma(ray_step, intersection_delta, ray_step * 0.5 + 0.5) * ray_delta;

    vec3 local_position = floor(fposition + 0.);
    float t_value = 0;
    while (
        all(greaterThanEqual(local_position, vec3(0))) 
        && all(lessThan(local_position, vec3(8))) 
        && hit.t + t_value <= t_max
    ) { 
        const int bit_offset = int(floor(local_position.x + 8 * (local_position.z + 8 * local_position.y)));
        const int mask_index = bit_offset / 32;
        const int mask_offset = bit_offset % 32;
        const uint uint_mask = solid_mask[mask_index];
        const uint bitfield_final_entry = bitfieldExtract(uint_mask, 0, mask_offset + 1);

        const bool hit_voxel = ((bitfield_final_entry & (1 << mask_offset)) != 0) && (t_value + hit.t) >= t_min;
        if (hit_voxel) {
            // hit.t = t_value + hit.t;
            // hit.point = RayAt(r, hit.t);
            brick_position = fma(local_position, vec3(voxel_scale), brick_position);
            return true;
        }

        // progress position with DDA
        const vec3 mask = vec3(lessThanEqual(side_dist.xyz, min(side_dist.yzx, side_dist.zxy)));
        t_value = vec3Reduce(mask * side_dist) * voxel_scale.x;
        side_dist += mask * ray_delta;
        local_position += mask * ray_step;
    } 

    return false;
}
