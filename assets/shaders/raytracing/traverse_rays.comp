#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

// See glsl 4.40 spec chapter 4.7.1 for info on infinity
// https://www.khronos.org/registry/OpenGL/specs/gl/GLSLangSpec.4.40.pdf
const float infinity = 0.001 / 0;
const float pi = 3.14159265358; // 3.1415926535897932385
const float faccuracy = 0.000001;

layout (set = 0, binding = 0) buffer InRayBufferCursor
{
    int in_ray_cursor;
};
layout (set = 0, binding = 1) readonly buffer InRayBuffer {
    Ray in_rays[];
};

layout (set = 0, binding = 2) buffer OutRayBufferCursor
{
    int out_ray_cursor;
};
layout (set = 0, binding = 3) writeonly buffer OutRayBuffer {
    Ray out_rays[];
};

layout (set = 0, binding = 4) uniform BrickGridState {
    // how many voxels in each axis
    vec3 voxel_dim;
    float padding0;

    // how many bricks in each axis
    vec3 dim;
    float padding1;

    vec3 min_point;
    float padding2;
    vec3 max_point;
    float scale;
} brick_grid;

bool AdvIntersect(vec3 box_min_point, vec3 box_max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max);

void main() {
    const int in_ray_index = atomicAdd(in_ray_cursor, -1);
    if (in_ray_index < 0) return;
    Ray ray = in_rays[in_ray_index];

    float t_min = 0.0001;
    float t_max = infinity;
    if (AdvIntersect(brick_grid.min_point, brick_grid.max_point, ray, 1 / ray.direction, t_min, t_max)) {
        ray.color = vec3(1);
    }
    ray.t_value += t_min;

    const int out_ray_index = atomicAdd(out_ray_cursor, 1);
    out_rays[out_ray_index] = ray;
}


float maxComponent(vec3 vec) {
    return max(max(vec.x, vec.y), vec.z);
}

float minComponent(vec3 vec) {
    return min(min(vec.x, vec.y), vec.z);
}

/// Test if a ray intersect with min point p0 and max p1 of a slab
/// This function will also computes the ray t_min and t_max and register a hit in a record in the event of an intersection
/// If calc_hit is false: only compute t values (t_min is still stored in hit.t)
/// 
/// Source: Ray tracing gems 2 & Peter Shirley
bool AdvIntersect(vec3 min_point, vec3 max_point, Ray r, vec3 inv_ray_dir, inout float t_min, inout float t_max) {
    const vec3 t_lower = (min_point - r.origin) * inv_ray_dir;
    const vec3 t_upper = (max_point - r.origin) * inv_ray_dir;

    const vec3 t_mins = vec3(min(t_lower, t_upper));
    const vec3 t_maxes = vec3(max(t_lower, t_upper));

    t_min = max(t_min, maxComponent(t_mins));
    t_max = min(t_max, minComponent(t_maxes));
    return t_min <= t_max;
}
