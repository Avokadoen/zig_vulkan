#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

#include "ray_commons.glsl"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) readonly buffer HitLimitBuffer {
    HitLimits limits;
};
layout (std430, set = 1, binding = 0) buffer RayBuffer {
    Ray rays[];
};
layout (std430, set = 2, binding = 0) readonly buffer RayHitBuffer {
    RayHit ray_hits[];
};
layout (std430, set = 3, binding = 0) buffer RayShadingBuffer {
    RayShading ray_shadings[];
};
layout (std430, set = 4, binding = 0) readonly buffer MaterialBuffer {
    vec4 materials[]; // TODO: materials is small enough to be in shared buffer
};
layout (std430, set = 4, binding = 1) readonly buffer MaterialIndexBuffer {
    uint material_indices_8b[];
};


const vec3 normal_map[] = vec3[](
    vec3(-1,  0,  0), // X_AXIS_LEFT_INDEX = 0;
    vec3( 0, -1,  0), // Y_AXIS_DOWN_INDEX = 1;
    vec3( 0,  0,  1), // Z_AXIS_FRONT_INDEX = 2;
    vec3( 1,  0,  0), // X_AXIS_RIGHT_INDEX = 3;
    vec3( 0,  1,  0), // Y_AXIS_UP_INDEX = 4;
    vec3( 0,  0, -1)  // Z_AXIS_BACK_INDEX = 5;
);

void main() {
    // get the index for ray and hit, max_index is copied over from out_cursor by pipeline
    const uint index = gl_GlobalInvocationID.x;
    if (index >= limits.out_hit_count) {
        return;
    }

    // extract material index and normal index
    uint normal_index_3b_voxel_index_9b_brick_index_20b = ray_hits[index].normal_index_3b_voxel_index_9b_brick_index_20b;
    
    const uint brick_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 0, 20);
    const uint voxel_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 20, 9);
    const uint normal_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 29, 3);

    // TODO actually scatter ray based on material_index and a scatter function (we also have hit_record.ray_direction)
    Ray ray = rays[index];
    const vec3 hit_normal = normal_map[normal_index];
    const vec3 scatter_dir = hit_normal;

    // get the index for the voxels material index
    const int material_indices_index = int(brick_index * 512 + voxel_index);
    // get the bits that contain the actual material index
    const uint material_index_bits = material_indices_8b[material_indices_index / 4];
    // extract the bits and get the final material index we care about
    const uint material_index = bitfieldExtract(material_index_bits, (material_indices_index % 4) * 8, 8);

    const Material material = Vec4ToMaterial(materials[material_index]);
    ray_shadings[index].color += material.albedo;


    // use old direction and move ray to hit point
    // HACK: scew origin by hit surface normal to avoid self intersections
    ray.origin = RayAt(ray, ray.t_value) + hit_normal * 0.1;
    ray.direction = scatter_dir;
    ray.t_value = 0;

    rays[index] = ray;
}


// bool scatterLambertian(Material material, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered) {
//     // TODO: better random hemisphere
//     vec3 scatter_dir = normalize(hit.normal + RandVec3(hit.point.xy + hit.point.z, -0.4, 0.4));
//     scattered = CreateRay(hit.point, scatter_dir, IGNORE_MAT_NONE);

//     attenuation = AlbedoColor(material);
//     return true;
// }

// bool scatterMetal(Material material, Ray r_in, HitRecord hit, out vec3 attenuation, out Ray scattered) {
//     vec3 reflected = reflect(r_in.direction, hit.normal);
//     float fuzz = metal[material.type_index].fuzz;
//     scattered = CreateRay(hit.point, reflected + RandVec3(hit.point.xy + hit.point.z, -fuzz, fuzz), IGNORE_MAT_NONE);
//     attenuation = AlbedoColor(material);
//     return (dot(scattered.direction, hit.normal) > 0);
// }

// // Source: Ray tracing gems 2 page 107 (one of Bec's methods)
// /// defined the refraction direction if a refraction is needed based on n1, n2 and the angle between
// /// r_in and the normal
// /// This means that refrac_dir only gets defined if function returns true
// /// @param:
// ///     - n1: internal reflection of impact material
// ///     - n2: internal reflection of current material medium
// ///     - ray_dir: the traveling ray direction
// ///     - normal: normal vector of the impact surface
// ///     - refrac_dir: poternial calculated penetration vector of r_in
// /// @return: bool that is true if refraction is calculated
// bool transmissionDirection(float n1, float n2, vec3 ray_dir, vec3 normal, out vec3 refrac_dir) {
//     const float eta = n1 / n2;
//     const float c1 = -dot(ray_dir, normal);
//     const float w = eta * c1;
//     const float c2m = (w - eta) * (w + eta);
//     if (c2m < -1.0) {
//         return false;
//     }
//     refrac_dir = fma(vec3(eta), ray_dir, (w - sqrt(1.0 + c2m)) * normal);
//     return true;
// }

// bool scatterDielectric(Material material, Ray r_in, vec3 hit_c_min, HitRecord hit, out vec3 attenuation, out Ray scattered) {
//     attenuation = AlbedoColor(material);

//     const float ir = dielectric[material.type_index].internal_reflection;

//     // TODO: better noise (blue :))
//     // TODO: add property to glass: roughness (0 should be no noise/rng)
//     const vec3 normal = normalize(hit.normal + RandVec3(hit.point.xy + hit.point.z, -0.05, 0.05));
//     vec3 direction;
//     const bool should_refract = transmissionDirection(ir, r_in.internal_reflection, r_in.direction, normal, direction);
//     if (should_refract && Rand(hit.point) > 0.5) {
//         scattered = CreateRay(hit.point, direction, IGNORE_MAT_NONE);
//         // TODO: we can remove this if we find the correct t_min for GridHit in calculate raycolor
//         // HACK: move scattered ray out of current cube explicitly
//         {
//             float t_max = 9999.0;
//             hit.t = 0;
//             const vec3 inv_ray_dir = 1 / r_in.direction;
//             AdvIntersect(hit_c_min - vec3(0.001), hit_c_min + vec3(0.126), scattered, inv_ray_dir, hit.t, t_max);
//             scattered = CreateRay(RayAt(scattered, t_max), scattered.direction, IGNORE_MAT_NONE);
//         }
//         // ray is traveling through non air medium
//         scattered.internal_reflection = ir;
//     } else {
//         direction = reflect(r_in.direction, normal);
//         scattered = CreateRay(hit.point, direction, IGNORE_MAT_NONE);
//     }

//     return true;
// }

