#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

#include "ray_commons.glsl"
#include "../rand.comp" // TODO: rename .glsl

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (std430, set = 0, binding = 0) readonly buffer HitLimitBuffer {
    HitLimits limits;
};
layout (std430, set = 1, binding = 0) buffer RayBuffer {
    Ray rays[];
};
layout (std430, set = 2, binding = 0) readonly buffer RayHitBuffer {
    RayHit ray_hits[];
};
layout (std430, set = 3, binding = 0) buffer RayShadingBuffer {
    RayShading ray_shadings[];
};
layout (std430, set = 4, binding = 0) readonly buffer MaterialBuffer {
    vec4 materials[]; // TODO: materials is small enough to be in shared buffer
};
layout (std430, set = 4, binding = 1) readonly buffer MaterialIndexBuffer {
    uint material_indices_8b[];
};

const vec3 normal_map[] = vec3[](
    vec3(-1,  0,  0), // X_AXIS_LEFT_INDEX = 0;
    vec3( 0, -1,  0), // Y_AXIS_DOWN_INDEX = 1;
    vec3( 0,  0,  1), // Z_AXIS_FRONT_INDEX = 2;
    vec3( 1,  0,  0), // X_AXIS_RIGHT_INDEX = 3;
    vec3( 0,  1,  0), // Y_AXIS_UP_INDEX = 4;
    vec3( 0,  0, -1)  // Z_AXIS_BACK_INDEX = 5;
);

void scatterLambertian(inout Ray r_in, vec3 hit_point, vec3 hit_normal);
void scatterMetal(inout Ray r_in, float fuzz, vec3 hit_point, vec3 hit_normal);
void scatterDielectric(inout Ray r_in, float ir, vec3 hit_point, vec3 hit_normal);

void main() {
    // get the index for ray and hit, max_index is copied over from out_cursor by pipeline
    const uint index = gl_GlobalInvocationID.x;
    if (index >= limits.out_hit_count) {
        return;
    }

    // extract material index and normal index
    uint normal_index_3b_voxel_index_9b_brick_index_20b = ray_hits[index].normal_index_3b_voxel_index_9b_brick_index_20b;
    
    const uint brick_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 0, 20);
    const uint voxel_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 20, 9);
    const uint normal_index = bitfieldExtract(normal_index_3b_voxel_index_9b_brick_index_20b, 29, 3);

    // TODO actually scatter ray based on material_index and a scatter function (we also have hit_record.ray_direction)
    Ray ray = rays[index];
    const vec3 hit_normal = normal_map[normal_index];

    // get the index for the voxels material index
    const int material_indices_index = int(brick_index * 512 + voxel_index);
    // get the bits that contain the actual material index
    const uint material_index_bits = material_indices_8b[material_indices_index / 4];
    // extract the bits and get the final material index we care about
    const uint material_index = bitfieldExtract(material_index_bits, (material_indices_index % 4) * 8, 8);

    const Material material = Vec4ToMaterial(materials[material_index]);
    ray_shadings[index].color *= material.albedo;

    const vec3 hit_point = RayAt(ray, ray.t_value);

    switch (material.type) {
        case MAT_T_LAMBERTIAN:
        scatterLambertian(ray, hit_point, hit_normal);
        break;

        case MAT_T_METAL:
        // if ray is absorbed in material
        scatterMetal(ray, material.type_value, hit_point, hit_normal);
        break;

        case MAT_T_DIELECTRIC: 
        scatterDielectric(ray, material.type_value, hit_point, hit_normal);
        break;

        default:
        // unreachable
        ray_shadings[index].color = vec3(1, 0, 0);
        ray.direction = hit_normal;
        break;
    }

    ray.t_value = 0;
    ray.direction = normalize(ray.direction);

    rays[index] = ray;
}


void scatterLambertian(inout Ray r_in, vec3 hit_point, vec3 hit_normal) {
    // TODO: better random hemisphere
    r_in.direction = normalize(hit_normal + RandVec3(hit_point.xy + hit_point.z, -0.6, 0.6));
    // HACK: scew origin by hit normal to avoid self intersections
    r_in.origin = hit_point;

    // TODO: buggy scenario: dielectric voxel refract straight to intersect with neighbouring voxel, we should not update internal relfection
    r_in.internal_reflection_16b_padding_15b_abort_ray_1b = packHalf2x16(vec2(1, 0));
}

void scatterMetal(inout Ray r_in, float fuzz, vec3 hit_point, vec3 hit_normal) {
    vec3 reflected = reflect(r_in.direction, hit_normal);
    r_in.direction = normalize(reflected + RandVec3(hit_point.xy + hit_point.z, -fuzz, fuzz));
    // HACK: scew origin by hit normal to avoid self intersections
    r_in.origin = hit_point;

    // TODO: buggy scenario: dielectric voxel refract straight to intersect with neighbouring voxel, we should not update internal relfection
    const uint abort_ray_traversal = uint(dot(r_in.direction, hit_normal) <= 0);
    r_in.internal_reflection_16b_padding_15b_abort_ray_1b = packHalf2x16(vec2(1, uintBitsToFloat(abort_ray_traversal)));
}

// Source: Ray tracing gems 2 page 107 (one of Bec's methods)
/// defined the refraction direction if a refraction is needed based on n1, n2 and the angle between
/// r_in and the normal
/// This means that refrac_dir only gets defined if function returns true
/// @param:
///     - n1: internal reflection of impact material
///     - n2: internal reflection of current material medium
///     - ray_dir: the traveling ray direction
///     - normal: normal vector of the impact surface
///     - refrac_dir: poternial calculated penetration vector of r_in
/// @return: bool that is true if refraction is calculated
bool transmissionDirection(float n1, float n2, vec3 ray_dir, vec3 normal, out vec3 refrac_dir) {
    const float eta = n1 / n2;
    const float c1 = -dot(ray_dir, normal);
    const float w = eta * c1;
    const float c2m = (w - eta) * (w + eta);
    if (c2m < -1.0) {
        return false;
    }
    refrac_dir = fma(vec3(eta), ray_dir, (w - sqrt(1.0 + c2m)) * normal);
    return true;
}

void scatterDielectric(inout Ray r_in, float material_ir, vec3 hit_point, vec3 hit_normal) {
    // TODO: better noise (blue :))
    // TODO: add property to glass: roughness (0 should be no noise/rng)
    const vec3 normal = normalize(hit_normal + RandVec3(hit_point.xy + hit_point.z, -0.05, 0.05));
    vec3 direction;

    float ray_ir = unpackHalf2x16(r_in.internal_reflection_16b_padding_15b_abort_ray_1b).x;

    const bool should_refract = transmissionDirection(material_ir, ray_ir, r_in.direction, normal, direction);
    if (should_refract && Rand(hit_point) > 0.5) {
        r_in.direction = direction;
        r_in.internal_reflection_16b_padding_15b_abort_ray_1b = packHalf2x16(vec2(material_ir, 0));
    } else {
        r_in.direction = reflect(r_in.direction, normal);
        // TODO: buggy scenario: dielectric voxel refract straight to intersect with neighbouring voxel, we should not update internal relfection
        r_in.internal_reflection_16b_padding_15b_abort_ray_1b = packHalf2x16(vec2(1, 0));
    }
}

