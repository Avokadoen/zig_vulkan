#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

#include "ray_commons.glsl"
#include "../rand.comp"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (push_constant) readonly uniform PushConstants {
    vec3 horizontal;
    uint image_width;
    vec3 vertical;
    uint image_height;
    vec3 lower_left_corner;
    int samples_per_pixel;
    vec3 origin;
    int max_bounce;
} push_constant;

layout (std430, set = 0, binding = 0) writeonly buffer HitLimitBuffer {
    HitLimits limits;
};
layout (std430, set = 1, binding = 0) writeonly buffer RayBuffer {
    Ray rays[];
};
layout (std430, set = 2, binding = 0) writeonly buffer RayHitBuffer {
    RayHit ray_hits[];
};
layout (std430, set = 3, binding = 0) writeonly buffer RayShadingBuffer {
    RayShading ray_shadings[];
};


void main() {
    // TODO: sequential indices should map to tiles in the image instead of stripes for better coherency
    const uint index = gl_GlobalInvocationID.x;

    ray_hits[index] = RayHit(
        0 // normal_4b_and_material_index_28b
    );

    const uvec2 pixel_coord = uvec2(
        index % push_constant.image_width,
        index / push_constant.image_width
    );

    if (pixel_coord.y >= push_constant.image_height) {
        return;
    }

    // TODO: emitted_hit_count can be set in the transfer queue
    atomicAdd(limits.emitted_hit_count, 1);
    // TODO: sorting might be a more effective way of getting this count, 
    atomicAdd(limits.in_hit_count, 1);

    // TODO: random dir when multi samples
    // TODO: proper random (blue noise)
    // TODO: remove division

    // also: "One way to do this is to read the texture at some fixed offset. 
    // For instance, if you read the first value at (pixelX, pixelY) % textureSize, 
    // you might read the second value at (pixelX+5, pixelY+7) % textureSize"
    // https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-2/

    const float u = float(pixel_coord.x) / float(push_constant.image_width - 1);
    const float v = float(pixel_coord.y) / float(push_constant.image_height - 1);
    
    const vec3 ray_dir = fma(push_constant.horizontal, vec3(u), push_constant.lower_left_corner) + fma(vec3(v), push_constant.vertical, -push_constant.origin);
    rays[index] = Ray(
        push_constant.origin,   // origin
        1,                      // internal_reflection
        normalize(ray_dir),     // direction
        0                       // t_value
    );


    const uint pixel = (pixel_coord.x << 16) | pixel_coord.y;
    ray_shadings[index] = RayShading(
        vec3(1),    // color
        pixel       // pixel_coord
    );
}
