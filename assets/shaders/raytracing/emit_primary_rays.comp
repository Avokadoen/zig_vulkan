#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"
#include "../rand.comp"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

// TODO: only need image width, height (and potentially image offset width and height)!
layout (push_constant) uniform PushConstants {
    vec3 horizontal;
    uint image_width;
    vec3 vertical;
    uint image_height;
    vec3 lower_left_corner;
    int samples_per_pixel;
    vec3 origin;
    int max_bounce;
} push_constant;

layout (set = 0, binding = 0) buffer RayBufferCursor
{
    int ray_cursor;
};
layout (set = 0, binding = 1) writeonly buffer RayBuffer {
    Ray rays[];
};

shared uint warp_start_index;

void main() {
    const uvec2 pixel_coord = uvec2(gl_GlobalInvocationID.x, gl_GlobalInvocationID.y);
    if (pixel_coord.x >= push_constant.image_width || pixel_coord.y >= push_constant.image_height) {
        // don't emit ray for discarded pixels
        return;
    }

    const float x = float(pixel_coord.x);
    const float y = float(pixel_coord.y);
    // TODO: proper random (blue noise)
    // TODO: remove division
    const float noise_x = hash12(vec2(x + sample_i, y) * 0.2 * float(sample_i > 0));
    const float u = (x + noise_x) / float(push_constant.image_width - 1);
    const float noise_y = hash12(vec2(x, y + sample_i) * 0.2 * float(sample_i > 0));
    const float v = (y + noise_y) / float(push_constant.image_height - 1);
    
    if (gl_LocalInvocationIndex == 0) {
        const uint work_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
        warp_start_index = work_size * atomicAdd(ray_cursor, 1);
    }
    barrier();
    
    const uint ray_index = warp_start_index + gl_LocalInvocationIndex;
    const vec3 ray_dir = fma(push_constant.horizontal, vec3(u), push_constant.lower_left_corner) + fma(vec3(v), push_constant.vertical, -push_constant.origin);
    const uint pixel = pixel_coord.x << 16 | pixel_coord.y;
    rays[ray_index] = Ray(
        push_constant.origin, // positions
        1,                    // internal_reflection
        ray_dir,              // direction
        IGNORE_MAT_NONE,      // ignore material
        vec3(0),              // color
        pixel                 // pixel coord
    );
}
