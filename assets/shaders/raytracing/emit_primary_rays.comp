#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"
#include "../rand.comp"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

// TODO: only need image width, height (and potentially image offset width and height)!
layout (push_constant) uniform PushConstants {
    vec3 horizontal;
    uint image_width;
    vec3 vertical;
    uint image_height;
    vec3 lower_left_corner;
    int samples_per_pixel;
    vec3 origin;
    int max_bounce;
} push_constant;

layout (set = 0, binding = 0) buffer CursorBuffer {
    RayBufferCursor cursor;
};
layout (set = 0, binding = 1) writeonly buffer RayBuffer {
    Ray rays[];
};

shared uint warp_start_index;

void main() {
    const uint pixel_count = push_constant.image_width * push_constant.image_height;
    if (gl_GlobalInvocationID.x >= pixel_count) {
        return;
    }

    if (gl_LocalInvocationIndex == 0) {
        const uint work_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
        warp_start_index = work_size * atomicAdd(cursor.cursor, 1);
    }
    barrier();
    
    const uint ray_index = warp_start_index + gl_LocalInvocationIndex;
    const uvec2 pixel_coord = uvec2(
        ray_index % push_constant.image_width, 
        ray_index / push_constant.image_width
    );
    if (pixel_coord.x > push_constant.image_width || pixel_coord.y > push_constant.image_height) {
        return;
    }
    atomicMax(cursor.max_index, int(ray_index));

    // TODO: random dir when multi samples
    // TODO: proper random (blue noise)
    // TODO: remove division
    const float u = float(pixel_coord.x) / float(push_constant.image_width - 1);
    const float v = float(pixel_coord.y) / float(push_constant.image_height - 1);
    
    const vec3 ray_dir = fma(push_constant.horizontal, vec3(u), push_constant.lower_left_corner) + fma(vec3(v), push_constant.vertical, -push_constant.origin);
    const uint pixel = (pixel_coord.x << 16) | pixel_coord.y;

    rays[ray_index] = Ray(
        push_constant.origin, // origin
        1,                    // internal_reflection
        ray_dir,              // direction
        0,                    // t value
        vec3(0),              // color
        pixel                 // pixel coord
    );
}
