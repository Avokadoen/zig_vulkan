#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

// This extension is strictly not required for vulkan 1.2 target, but is used to silence validator...
#extension GL_GOOGLE_include_directive : enable
#include "ray_commons.glsl"
#include "../rand.comp"

layout(local_size_x_id = 0, local_size_y_id = 1, local_size_z = 1) in;

layout (push_constant) uniform PushConstants {
    vec3 horizontal;
    uint image_width;
    vec3 vertical;
    uint image_height;
    vec3 lower_left_corner;
    int samples_per_pixel;
    vec3 origin;
    int max_bounce;
} push_constant;

layout (set = 0, binding = 0) buffer EmitCursorBuffer {
    RayBufferCursor emit_cursor;
};
layout (set = 0, binding = 1) buffer DrawCursorBuffer {
    RayBufferCursor draw_cursor;
};
layout (set = 0, binding = 2) writeonly buffer HitRecordBuffer {
    HitRecord initial_records[];
};

shared uint warp_start_index;

void main() {
    if (gl_LocalInvocationIndex == 0) {
        const uint work_size = gl_WorkGroupSize.x * gl_WorkGroupSize.y * gl_WorkGroupSize.z;
        warp_start_index = work_size * atomicAdd(emit_cursor.cursor, 1);
    }
    barrier();
    
    const uint ray_index = warp_start_index + gl_LocalInvocationIndex;
    const uvec2 pixel_coord = uvec2(
        ray_index % push_constant.image_width, 
        ray_index / push_constant.image_width
    );
    if (pixel_coord.y > push_constant.image_height) {
        return;
    }

    // TODO: random dir when multi samples
    // TODO: proper random (blue noise)
    // TODO: remove division
    const float u = float(pixel_coord.x) / float(push_constant.image_width - 1);
    const float v = float(pixel_coord.y) / float(push_constant.image_height - 1);
    
    const vec3 ray_dir = fma(push_constant.horizontal, vec3(u), push_constant.lower_left_corner) + fma(vec3(v), push_constant.vertical, -push_constant.origin);
    const uint pixel = (pixel_coord.x << 16) | pixel_coord.y;

    atomicMax(emit_cursor.max_index, int(ray_index));
    atomicMax(draw_cursor.max_index, int(ray_index));

    initial_records[ray_index] = HitRecord(
        push_constant.origin,   // point
        0,                      // normal_4b_and_material_index_28b
        ray_dir,                // previous_ray_direction
        1,                      // previous_ray_internal_reflection
        vec3(0),                // previous_color
        pixel,                  // pixel_coord
        vec3(0),                // padding
        0                       // t_value
    );
}
