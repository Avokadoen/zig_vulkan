#version 450

#extension GL_EXT_debug_printf : disable
// debugPrintfEXT("hello world %f", 1.0);

#include "ray_commons.glsl"
#include "../rand.comp"

layout(local_size_x_id = 0, local_size_y = 1, local_size_z = 1) in;

layout (push_constant) readonly uniform PushConstants {
    vec3 horizontal;
    uint image_width;
    vec3 vertical;
    uint image_height;
    vec3 lower_left_corner;
    uint current_sample; 
    vec3 origin;
} push_constant;

layout (std430, set = 0, binding = 0) writeonly buffer HitLimitBuffer {
    HitLimits limits;
};
layout (std430, set = 1, binding = 0) writeonly buffer RayBuffer {
    Ray rays[];
};
layout (std430, set = 2, binding = 0) writeonly buffer RayHitBuffer {
    RayHit ray_hits[];
};
layout (std430, set = 3, binding = 0) writeonly buffer RayShadingBuffer {
    RayShading ray_shadings[];
};

const uint sample_offset_x = 3;
const uint sample_offset_y = 4;

void main() {
    // TODO: sequential indices should map to tiles in the image instead of stripes for better coherency
    const uint index = gl_GlobalInvocationID.x;

    ray_hits[index] = RayHit(
        0 // normal_4b_and_material_index_28b
    );

    uvec2 pixel_coord = uvec2(
        (index % push_constant.image_width),
        (index / push_constant.image_width)
    );

    if (pixel_coord.y >= push_constant.image_height) {
        return;
    }

    // TODO: emitted_hit_count can be set in the transfer queue
    atomicAdd(limits.emitted_hit_count, 1);
    // TODO: sorting might be a more effective way of getting this count, 
    atomicAdd(limits.in_hit_count, 1);

    // TODO: proper random (blue noise)
    // TODO: remove division

    // also: "One way to do this is to read the texture at some fixed offset. 
    // For instance, if you read the first value at (pixelX, pixelY) % textureSize, 
    // you might read the second value at (pixelX+5, pixelY+7) % textureSize"
    // https://developer.nvidia.com/blog/rendering-in-real-time-with-spatiotemporal-blue-noise-textures-part-2/

    // sample as if we were using blue noise (which is the plan)
    const float uv_noise_u_offset = pixel_coord.x + sample_offset_x * push_constant.current_sample;
    const float uv_noise_u = push_constant.current_sample > 0 ? Rand(vec2(uv_noise_u_offset, pixel_coord.y)) : 0;
    const float u = float(pixel_coord.x + uv_noise_u) / float(push_constant.image_width - 1);

    const float uv_noise_v_offset = pixel_coord.y + sample_offset_y * push_constant.current_sample;
    const float uv_noise_v = push_constant.current_sample > 0 ? Rand(vec2(pixel_coord.x, uv_noise_v_offset)) : 0;
    const float v = float(pixel_coord.y + uv_noise_v) / float(push_constant.image_height - 1);
    
    const vec3 ray_dir = fma(push_constant.horizontal, vec3(u), push_constant.lower_left_corner) + fma(vec3(v), push_constant.vertical, -push_constant.origin);
    rays[index] = Ray(
        push_constant.origin,      // origin
        packHalf2x16(vec2(1, 0)),  // internal_reflection_16b_padding_15b_abort_ray_1b
        normalize(ray_dir),        // direction
        0                          // t_value
    );


    const uint pixel = (pixel_coord.x << 16) | pixel_coord.y;
    ray_shadings[index] = RayShading(
        vec3(1),    // color
        pixel       // pixel_coord
    );
}
